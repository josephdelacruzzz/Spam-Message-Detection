# -*- coding: utf-8 -*-
"""Spam Message Detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v0bFPDwM0prRQB3MdaSxVV1IHKLBmZCq
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

import pickle
import tensorflow as tf

from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import Flatten
from tensorflow.keras.layers import Dropout
from tensorflow.keras.layers import Embedding
from tensorflow.keras.callbacks import EarlyStopping

from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import CountVectorizer as cv

df = pd.read_csv("spam.csv")

data = df.copy()
data.drop(columns = ["Unnamed: 2", "Unnamed: 3", "Unnamed: 4"], inplace = True)

data = data.rename(columns={"v1":"label", "v2":"text"})

data['label'] = data['label'].map({'spam': 1, 'ham': 0})

# import re
# import nltk
# from nltk.corpus import stopwords
# from nltk.stem.porter import PorterStemmer
# ps = PorterStemmer()
# corpus = []

# for i in range(0, len(data)):
#   review = re.sub('[^a-zA-Z]',' ', data['message'][i])
#   review = review.lower()
#   review = review.split()
#   review = [ps.stem(word) for word in review if not word in stopwords.words('english')]
#   review = ' '.join(review)
#   corpus.append(review)

X = data['text'].values
y = data['label'].values
X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.20, random_state=42)

t = Tokenizer()
t.fit_on_texts(X_train)

encoded_train = t.texts_to_sequences(X_train)
encoded_test = t.texts_to_sequences(X_test)
print(encoded_train[0:2])

max_length = 8
padded_train = pad_sequences(encoded_train, maxlen=max_length, padding='post')
padded_test = pad_sequences(encoded_test, maxlen=max_length, padding='post')
print(padded_train)

vocab_size = len(t.word_index) + 1

model = Sequential()
model.add(Embedding(vocab_size, 24, input_length = max_length))
model.add(Flatten())
model.add(Dense(500, activation='relu'))
model.add(Dense(200, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(100, activation='relu'))
model.add(Dense(1, activation='sigmoid'))

model.compile(optimizer='rmsprop', loss='binary_crossentropy', metrics=['accuracy'])

print(model.summary())

early_stop = EarlyStopping(monitor='val_loss', mode='min', verbose = 1, patience = 10)

model.fit(x=padded_train,
          y=y_train,
          epochs=50,
          validation_data=(padded_test, y_test), verbose =1,
          callbacks=[early_stop]
          )

from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

def c_report(y_true, y_pred):
  print("Classification Report")
  print(classification_report(y_true, y_pred))
  acc_sc = accuracy_score(y_true, y_pred)
  print("Accuracy :" + str(acc_sc))
  return acc_sc

def plot_confusion_matrix(y_true, y_pred):
  mtx = confusion_matrix(y_true, y_pred)
  sns.heatmap(mtx, annot=True, fmt='d', linewidths=.5,
              cmap="Blues", cbar=False)
  plt.ylabel('True label')
  plt.xlabel('Predicted label')

preds = (model.predict(padded_test) > 0.5).astype("int32")

c_report(y_test,preds)
plot_confusion_matrix(y_test, preds)

def predict_email(text):
    # Tokenize the email text
    encoded_email = t.texts_to_sequences([text])

    # Pad the tokenized email text
    padded_email = pad_sequences(encoded_email, maxlen=max_length, padding='post')

    # Predict using the trained model
    prediction = (model.predict(padded_email) > 0.5).astype("int32")

    # Return the prediction
    if prediction[0] == 1:
      print("The string is predicted as SPAM.")
    else:
      print("The string is predicted as NOT SPAM.")

email_text = "We are excited to inform you that you have been selected as the prize winner for our giveaway. you have won a very real prize package worth one million dollars"

# Predict if the email is spam or ham
result = predict_email(email_text)
print(result)